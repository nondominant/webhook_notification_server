export declare const r2gSmokeTest: () => boolean;
export interface LinkedQueueValue<T> {
    after?: LinkedQueueValue<T>;
    before?: LinkedQueueValue<T>;
    value: T;
    key: any;
}
export declare type IteratorFunction<T, V> = (val: LinkedQueueValue<T>, index: number) => V;
export declare class LinkedQueue<T, K = any> {
    private lookup;
    private head;
    private tail;
    length: number;
    constructor();
    getLength(): number;
    getSize(): number;
    getRandomKey(): K;
    getRandomItem(): LinkedQueueValue<T>;
    remove(k: any): LinkedQueueValue<T>;
    contains(k: any): boolean;
    get(k: any): LinkedQueueValue<T>;
    peek(): LinkedQueueValue<T>;
    getOrderedList(): Array<LinkedQueueValue<T>>;
    static getKeyValue(v: LinkedQueueValue<any>): {
        key: any;
        value: any;
    };
    forEach(fn: IteratorFunction<T, void>, ctx?: any): this;
    map(fn: IteratorFunction<T, any>, ctx?: any): Array<any>;
    filter(fn: IteratorFunction<T, boolean>, ctx?: any): LinkedQueueValue<T>[];
    insertInFrontOf(): void;
    insertBehind(): void;
    insertAtIndex(): void;
    first(): LinkedQueueValue<T>;
    last(): LinkedQueueValue<T>;
    getReverseOrderedList(): Array<LinkedQueueValue<T>>;
    removeAll(): void;
    addToFront(k: any, obj?: any): void;
    enq(...args: Array<any>): void;
    deq(n: number): LinkedQueueValue<T>[];
    dequeue(): LinkedQueueValue<T>;
    enqueue(k: any, obj?: any): void;
    removeLast(): LinkedQueueValue<T>;
    clear(): any;
    unshift(k: any, obj?: any): void;
    push(k: any, obj?: any): void;
    add(k: any, obj?: any): void;
    shift(): LinkedQueueValue<T>;
    pop(): LinkedQueueValue<T>;
}
