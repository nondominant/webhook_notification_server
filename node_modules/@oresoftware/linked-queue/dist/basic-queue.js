'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
class BasicQueue {
    constructor() {
        this.lookup = {};
        this.first = 0;
        this.last = 0;
        this.length = 0;
        this.elementExists = false;
    }
    peek() {
        return this.lookup[this.first];
    }
    getByIndex(v) {
        return this.lookup[v];
    }
    getLength() {
        return this.length;
    }
    pop() {
        const last = this.last;
        if (this.elementExists && this.first === this.last) {
            this.length--;
            this.elementExists = false;
        }
        else if (this.last > this.first) {
            this.length--;
            this.last--;
        }
        const v = this.lookup[last];
        delete this.lookup[last];
        return v;
    }
    shift() {
        const first = this.first;
        if (this.elementExists && this.first === this.last) {
            this.length--;
            this.elementExists = false;
        }
        else if (this.first < this.last) {
            this.length--;
            this.first++;
        }
        const v = this.lookup[first];
        delete this.lookup[first];
        return v;
    }
    push(v) {
        this.length++;
        if (this.elementExists && this.first === this.last) {
            this.last++;
        }
        else if (this.first === this.last) {
            this.elementExists = true;
        }
        else {
            this.last++;
        }
        return this.lookup[this.last] = v;
    }
    unshift(v) {
        this.length++;
        if (this.elementExists && this.first === this.last) {
            this.first--;
        }
        else if (this.first === this.last) {
            this.elementExists = true;
        }
        else {
            this.first--;
        }
        return this.lookup[this.first] = v;
    }
    enq(v) {
        return this.push.apply(this, arguments);
    }
    enqueue(v) {
        return this.push.apply(this, arguments);
    }
    deq() {
        return this.shift.apply(this, arguments);
    }
    dequeue() {
        return this.shift.apply(this, arguments);
    }
    addToFront(v) {
        return this.unshift.apply(this, arguments);
    }
    removeAll() {
        return this.clear.apply(this, arguments);
    }
    clear() {
        this.length = 0;
        this.elementExists = false;
        this.first = 0;
        this.last = 0;
        this.lookup = {};
    }
}
exports.BasicQueue = BasicQueue;
