'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.RWLockWritePrefClient = exports.log = void 0;
const chalk_1 = require("chalk");
const UUID = require("uuid");
const client_1 = require("./client");
const we_are_debugging_1 = require("./we-are-debugging");
exports.log = {
    info: console.log.bind(console, chalk_1.default.gray.bold('lmx client info:')),
    warn: console.error.bind(console, chalk_1.default.magenta.bold('lmx client warning:')),
    error: console.error.bind(console, chalk_1.default.red.bold('lmx client error:')),
    debug: function (...args) {
        we_are_debugging_1.weAreDebugging && console.log('lmx debugging:', ...args);
    }
};
class RWLockWritePrefClient extends client_1.Client {
    constructor(o, cb) {
        super(o, cb);
        this.readerCounts = {};
        this.writeKeys = {};
    }
    beginReadp(key, opts) {
        return new Promise((resolve, reject) => {
            this.acquireReadLock(key, opts, (err, val) => {
                err ? reject(err) : resolve(val);
            });
        });
    }
    endReadp(key, opts) {
        return new Promise((resolve, reject) => {
            this.releaseReadLock(key, opts, (err, val) => {
                err ? reject(err) : resolve(val);
            });
        });
    }
    beginWritep(key, opts) {
        return new Promise((resolve, reject) => {
            this.acquireWriteLock(key, opts, (err, val) => {
                err ? reject(err) : resolve(val);
            });
        });
    }
    endWritep(key, opts) {
        return new Promise((resolve, reject) => {
            this.releaseWriteLock(key, opts, (err, val) => {
                err ? reject(err) : resolve(val);
            });
        });
    }
    acquireWriteLockp(key, opts) {
        return new Promise((resolve, reject) => {
            this.acquireWriteLock(key, opts, (err, val) => {
                err ? reject(err) : resolve(val);
            });
        });
    }
    acquireReadLockp(key, opts) {
        return new Promise((resolve, reject) => {
            this.acquireReadLock(key, opts, (err, val) => {
                err ? reject(err) : resolve(val);
            });
        });
    }
    releaseWriteLockp(key, opts) {
        return new Promise((resolve, reject) => {
            this.releaseWriteLock(key, opts, (err, val) => {
                err ? reject(err) : resolve(val);
            });
        });
    }
    releaseReadLockp(key, opts) {
        return new Promise((resolve, reject) => {
            this.releaseReadLock(key, opts, (err, val) => {
                err ? reject(err) : resolve(val);
            });
        });
    }
    acquireWriteLock(key, opts, cb) {
        try {
            [key, opts, cb] = this.parseUnlockOpts(key, opts, cb);
        }
        catch (err) {
            return process.nextTick(cb, err);
        }
        opts.max = 1;
        const boundRelease = this.releaseWriteLock.bind(this, key, {});
        this.lock(key, opts, (err, unlock) => {
            if (err) {
                return cb(err, boundRelease);
            }
            exports.log.debug(chalk_1.default.blue('acquireWriteLock got lock on:'), key);
            this.registerWriteFlagAndReadersCheck(key, {}, (err, val) => {
                if (err) {
                    return cb(err, boundRelease);
                }
                unlock((err, val) => {
                    exports.log.debug(chalk_1.default.blue('acquireWriteLock released lock on:'), key);
                    cb(err, boundRelease);
                });
            });
        });
    }
    releaseWriteLock(key, opts, cb) {
        try {
            [key, opts, cb] = this.parseUnlockOpts(key, opts, cb);
        }
        catch (err) {
            return process.nextTick(cb, err);
        }
        opts.max = 1;
        this.lock(key, opts, (err, unlock) => {
            if (err) {
                return cb(err, unlock);
            }
            exports.log.debug(chalk_1.default.blue('releaseWriteLock got lock on:'), key);
            this.setWriteFlagToFalse(key, (err, val) => {
                if (err) {
                    return cb(err, unlock);
                }
                unlock((err, val) => {
                    exports.log.debug(chalk_1.default.blue('releaseWriteLock released lock on:'), key);
                    cb(err, val);
                });
            });
        });
    }
    acquireReadLock(key, opts, cb) {
        try {
            [key, opts, cb] = this.parseUnlockOpts(key, opts, cb);
        }
        catch (err) {
            return process.nextTick(cb, err);
        }
        const boundRelease = this.releaseReadLock.bind(this, key, {});
        opts.max = 1;
        this.lock(key, opts, (err, unlock) => {
            if (err) {
                return cb(err, boundRelease);
            }
            exports.log.debug(chalk_1.default.blue('acquireReadLock got lock on key:'), key);
            this.registerWriteFlagCheck(key, {}, (err, val) => {
                if (err) {
                    return cb(err, boundRelease);
                }
                exports.log.debug(chalk_1.default.magenta('client got register-write-flag-and-readers-check-success'));
                unlock((err, val) => {
                    exports.log.debug(chalk_1.default.blue('acquireReadLock released lock on key:'), key);
                    cb(err, boundRelease);
                });
            });
        });
    }
    releaseReadLock(key, opts, cb) {
        try {
            [key, opts, cb] = this.parseUnlockOpts(key, opts, cb);
        }
        catch (err) {
            return process.nextTick(cb, err);
        }
        opts.max = 1;
        this.lock(key, opts, (err, unlock) => {
            if (err) {
                return cb(err, unlock);
            }
            exports.log.debug(chalk_1.default.blue('releaseReadLock got lock on key:'), key);
            this.decrementReaders(key, (err, val) => {
                if (err) {
                    return cb(err, unlock);
                }
                unlock((err, val) => {
                    exports.log.debug(chalk_1.default.blue('releaseReadLock released lock on key:'), key);
                    cb(err, val);
                });
            });
        });
    }
    registerWriteFlagCheck(key, opts, cb) {
        const uuid = UUID.v4();
        this.resolutions[uuid] = (err, val) => {
            delete this.resolutions[uuid];
            exports.log.debug(chalk_1.default.magenta('client got register-write-flag-check'));
            return cb(err, val);
        };
        this.write({ key, uuid, type: 'register-write-flag-check' });
    }
    registerWriteFlagAndReadersCheck(key, opts, cb) {
        const uuid = UUID.v4();
        this.resolutions[uuid] = (err, val) => {
            delete this.resolutions[uuid];
            cb(err, val);
        };
        this.write({
            key,
            uuid,
            type: 'register-write-flag-and-readers-check'
        });
    }
    incrementReaders(key, cb) {
        const uuid = UUID.v4();
        this.resolutions[uuid] = cb;
        this.write({
            uuid,
            type: 'increment-readers',
            key
        });
    }
    decrementReaders(key, cb) {
        const uuid = UUID.v4();
        this.resolutions[uuid] = cb;
        this.write({
            uuid,
            type: 'decrement-readers',
            key
        });
    }
    setWriteFlagToFalse(key, cb) {
        const uuid = UUID.v4();
        this.resolutions[uuid] = cb;
        this.write({
            uuid,
            type: 'set-write-flag-false-and-broadcast',
            key
        });
    }
}
exports.RWLockWritePrefClient = RWLockWritePrefClient;
