'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.log = void 0;
const util = require("util");
const net = require("net");
const readline = require("readline");
const chalk_1 = require("chalk");
const json_parser_1 = require("./json-parser");
exports.log = {
    info: console.log.bind(console, ' [live-mutex client]'),
    error: console.error.bind(console, ' [live-mutex client]')
};
const port = parseInt(process.argv[2] || process.env.live_mutex_port || '6970');
const host = process.argv[3] || process.env.live_mutex_host || 'localhost';
const s = net.createConnection({ port, host });
s.setEncoding('utf8');
s.once('error', function (e) {
    exports.log.error(chalk_1.default.magentaBright('socket experienced an error:'), '\n', util.inspect(e, { breakLength: Infinity }));
});
s.pipe(json_parser_1.createParser()).on('data', function (d) {
    console.log('server response:', String(d.inspectResult));
    process.stdout.write(prompt);
});
const acceptableCommands = {
    'lockcount': true,
    'clientcount': true,
    'clear': true,
    'help': true
};
const prompt = chalk_1.default.blueBright(`(${host}:${port})`) + chalk_1.default.blueBright.bold(` lmx > `);
s.once('connect', function () {
    console.log(chalk_1.default.green('client is connected to live-mutex broker at port:'), chalk_1.default.greenBright.bold(String(port)));
    process.stdout.write(prompt);
    let resetCurrentLine = function () {
        readline.clearLine(process.stdout, 0);
        readline.cursorTo(process.stdout, 0);
        process.stdout.write(prompt);
    };
    let currentLine = '', previousCmd = '';
    let commands = [];
    process.stdin.setRawMode(true);
    process.stdin.on('data', (buf) => {
        const str = String(buf);
        const charAsAscii = String(buf.toString().charCodeAt(0));
        switch (charAsAscii) {
            case '9':
                let matches = Object.keys(acceptableCommands).filter(v => String(v).startsWith(currentLine));
                if (matches.length !== 1) {
                    process.stdout.write('\n');
                    console.log(matches);
                    process.stdout.write(prompt + currentLine);
                    return;
                }
                resetCurrentLine();
                currentLine = matches[0];
                process.stdout.write(currentLine);
                break;
            case '3':
                console.log('\nYou pressed Ctrl-C. Sending SIGINT.');
                process.kill(process.pid, 'SIGINT');
                break;
            case '4':
                console.log('\nYou pressed Ctrl-D. Bye!');
                process.exit(0);
                break;
            case '12':
                process.stdout.write('\x1Bc');
                process.stdout.write(prompt);
                break;
            case '13':
                process.stdout.write('\n');
                currentLine && commands.push(currentLine);
                process.stdin.emit('linex', currentLine || '');
                currentLine = '';
                break;
            case '27':
                previousCmd = commands.pop();
                currentLine = previousCmd;
                resetCurrentLine();
                process.stdout.write(previousCmd);
                break;
            case '127':
                resetCurrentLine();
                currentLine = '';
                break;
            default:
                process.stdout.write(str);
                currentLine += str || '';
        }
    });
    process.stdin.on('linex', function (d) {
        readline.clearLine(process.stdout, 0);
        readline.cursorTo(process.stdout, 0);
        const lc = String(d || '').trim().toLowerCase();
        if (!lc) {
            process.stdout.write(prompt);
            return;
        }
        if (lc === 'clear') {
            process.stdout.write('\x1Bc');
            process.stdout.write(prompt);
            return;
        }
        if (lc === 'help') {
            console.log(chalk_1.default.bold('Available commands:'));
            console.log(Object.keys(acceptableCommands));
            process.stdout.write(prompt);
            return;
        }
        if (acceptableCommands[lc]) {
            console.log('sending message to server:', String(d));
            s.write(JSON.stringify({ inspectCommand: String(d) }) + '\n');
        }
        else {
            console.log('Command not recognized:', lc);
            console.log('Try using "help" to view available commands.');
            process.stdout.write(prompt);
        }
    });
    process.stdin.on('close', () => {
        console.log('\n Hope you enjoyed your time here!');
        process.exit(0);
    });
});
